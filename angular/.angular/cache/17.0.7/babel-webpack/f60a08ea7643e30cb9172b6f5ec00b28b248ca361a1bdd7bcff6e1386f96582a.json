{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { Subject, mergeMap, finalize, Observable } from 'rxjs';\nvar UploadStatus;\n(function (UploadStatus) {\n  UploadStatus[UploadStatus[\"Queue\"] = 0] = \"Queue\";\n  UploadStatus[UploadStatus[\"Uploading\"] = 1] = \"Uploading\";\n  UploadStatus[UploadStatus[\"Done\"] = 2] = \"Done\";\n  UploadStatus[UploadStatus[\"Cancelled\"] = 3] = \"Cancelled\";\n})(UploadStatus || (UploadStatus = {}));\nfunction humanizeBytes(bytes) {\n  if (bytes === 0) {\n    return '0 Byte';\n  }\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nclass NgUploaderService {\n  constructor(concurrency = Number.POSITIVE_INFINITY, contentTypes = ['*'], maxUploads = Number.POSITIVE_INFINITY, maxFileSize = Number.POSITIVE_INFINITY) {\n    this.queue = [];\n    this.serviceEvents = new EventEmitter();\n    this.uploadScheduler = new Subject();\n    this.subs = [];\n    this.contentTypes = contentTypes;\n    this.maxUploads = maxUploads;\n    this.maxFileSize = maxFileSize;\n    this.uploadScheduler.pipe(mergeMap(upload => this.startUpload(upload), concurrency)).subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n  }\n  handleFiles(incomingFiles) {\n    const allowedIncomingFiles = [].reduce.call(incomingFiles, (acc, checkFile, i) => {\n      const futureQueueLength = acc.length + this.queue.length + 1;\n      if (this.isContentTypeAllowed(checkFile.type) && futureQueueLength <= this.maxUploads && this.isFileSizeAllowed(checkFile.size)) {\n        acc = acc.concat(checkFile);\n      } else {\n        const rejectedFile = this.makeUploadFile(checkFile, i);\n        this.serviceEvents.emit({\n          type: 'rejected',\n          file: rejectedFile\n        });\n      }\n      return acc;\n    }, []);\n    this.queue.push(...allowedIncomingFiles.map((file, i) => {\n      const uploadFile = this.makeUploadFile(file, i);\n      this.serviceEvents.emit({\n        type: 'addedToQueue',\n        file: uploadFile\n      });\n      return uploadFile;\n    }));\n    this.serviceEvents.emit({\n      type: 'allAddedToQueue'\n    });\n  }\n  initInputEvents(input) {\n    return input.subscribe(event => {\n      switch (event.type) {\n        case 'uploadFile':\n          const uploadFileIndex = this.queue.findIndex(file => file === event.file);\n          if (uploadFileIndex !== -1 && event.file) {\n            this.uploadScheduler.next({\n              file: this.queue[uploadFileIndex],\n              event: event\n            });\n          }\n          break;\n        case 'uploadAll':\n          const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n          files.forEach(file => this.uploadScheduler.next({\n            file: file,\n            event: event\n          }));\n          break;\n        case 'cancel':\n          const id = event.id || null;\n          if (!id) {\n            return;\n          }\n          const subs = this.subs.filter(sub => sub.id === id);\n          subs.forEach(sub => {\n            if (sub.sub) {\n              sub.sub.unsubscribe();\n              const fileIndex = this.queue.findIndex(file => file.id === id);\n              if (fileIndex !== -1) {\n                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n                this.serviceEvents.emit({\n                  type: 'cancelled',\n                  file: this.queue[fileIndex]\n                });\n              }\n            }\n          });\n          break;\n        case 'cancelAll':\n          this.subs.forEach(sub => {\n            if (sub.sub) {\n              sub.sub.unsubscribe();\n            }\n            const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n            if (file) {\n              file.progress.status = UploadStatus.Cancelled;\n              this.serviceEvents.emit({\n                type: 'cancelled',\n                file: file\n              });\n            }\n          });\n          break;\n        case 'remove':\n          if (!event.id) {\n            return;\n          }\n          const i = this.queue.findIndex(file => file.id === event.id);\n          if (i !== -1) {\n            const file = this.queue[i];\n            this.queue.splice(i, 1);\n            this.serviceEvents.emit({\n              type: 'removed',\n              file: file\n            });\n          }\n          break;\n        case 'removeAll':\n          if (this.queue.length) {\n            this.queue = [];\n            this.serviceEvents.emit({\n              type: 'removedAll'\n            });\n          }\n          break;\n      }\n    });\n  }\n  startUpload(upload) {\n    return new Observable(observer => {\n      const sub = this.uploadFile(upload.file, upload.event).pipe(finalize(() => {\n        if (!observer.closed) {\n          observer.complete();\n        }\n      })).subscribe({\n        next: output => {\n          observer.next(output);\n        },\n        error: err => {\n          observer.error(err);\n          observer.complete();\n        },\n        complete: () => {\n          observer.complete();\n        }\n      });\n      this.subs.push({\n        id: upload.file.id,\n        sub: sub\n      });\n    });\n  }\n  uploadFile(file, event) {\n    return new Observable(observer => {\n      const url = event.url || '';\n      const method = event.method || 'POST';\n      const data = event.data || {};\n      const headers = event.headers || {};\n      const xhr = new XMLHttpRequest();\n      const time = new Date().getTime();\n      let progressStartTime = file.progress.data && file.progress.data.startTime || time;\n      let speed = 0;\n      let eta = null;\n      xhr.open(method, url, true);\n      xhr.withCredentials = event.withCredentials ? true : false;\n      xhr.upload.onprogress = e => {\n        if (e.lengthComputable) {\n          const percentage = Math.round(e.loaded * 100 / e.total);\n          const diff = new Date().getTime() - time;\n          speed = Math.round(e.loaded / diff * 1000);\n          progressStartTime = file.progress.data && file.progress.data.startTime || new Date().getTime();\n          eta = Math.ceil((e.total - e.loaded) / speed);\n          file.progress = {\n            status: UploadStatus.Uploading,\n            data: {\n              percentage: percentage,\n              speed: speed,\n              speedHuman: `${humanizeBytes(speed)}/s`,\n              startTime: progressStartTime,\n              endTime: null,\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta)\n            }\n          };\n          observer.next({\n            type: 'uploading',\n            file: file\n          });\n        }\n      };\n      xhr.upload.ontimeout = e => {\n        observer.error(e);\n        observer.complete();\n      };\n      xhr.upload.onerror = e => {\n        observer.error(e);\n        observer.complete();\n      };\n      xhr.upload.onabort = () => {\n        observer.complete();\n      };\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          const speedAverage = Math.round(file.size / (new Date().getTime() - progressStartTime) * 1000);\n          file.progress = {\n            status: UploadStatus.Done,\n            data: {\n              percentage: 100,\n              speed: speedAverage,\n              speedHuman: `${humanizeBytes(speedAverage)}/s`,\n              startTime: progressStartTime,\n              endTime: new Date().getTime(),\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta || 0)\n            }\n          };\n          file.responseStatus = xhr.status;\n          try {\n            file.response = JSON.parse(xhr.response);\n          } catch (e) {\n            file.response = xhr.response;\n          }\n          file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n          observer.next({\n            type: 'done',\n            file: file\n          });\n          observer.complete();\n        }\n      };\n      try {\n        const uploadFile = file.nativeFile;\n        const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n        if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n          observer.complete();\n        }\n        Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n        let bodyToSend;\n        if (event.includeWebKitFormBoundary !== false) {\n          Object.keys(data).forEach(key => file.form.append(key, data[key]));\n          file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n          bodyToSend = file.form;\n        } else {\n          bodyToSend = uploadFile;\n        }\n        this.serviceEvents.emit({\n          type: 'start',\n          file: file\n        });\n        xhr.send(bodyToSend);\n      } catch (e) {\n        observer.complete();\n      }\n      return () => {\n        xhr.abort();\n      };\n    });\n  }\n  secondsToHuman(sec) {\n    return new Date(sec * 1000).toISOString().substr(11, 8);\n  }\n  generateId() {\n    return Math.random().toString(36).substring(7);\n  }\n  setContentTypes(contentTypes) {\n    if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\n      if (contentTypes.find(type => type === '*') !== undefined) {\n        this.contentTypes = ['*'];\n      } else {\n        this.contentTypes = contentTypes;\n      }\n      return;\n    }\n    this.contentTypes = ['*'];\n  }\n  allContentTypesAllowed() {\n    return this.contentTypes.find(type => type === '*') !== undefined;\n  }\n  isContentTypeAllowed(mimetype) {\n    if (this.allContentTypesAllowed()) {\n      return true;\n    }\n    return this.contentTypes.find(type => type === mimetype) !== undefined;\n  }\n  isFileSizeAllowed(fileSize) {\n    if (!this.maxFileSize) {\n      return true;\n    }\n    return fileSize <= this.maxFileSize;\n  }\n  makeUploadFile(file, index) {\n    return {\n      fileIndex: index,\n      id: this.generateId(),\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      form: new FormData(),\n      progress: {\n        status: UploadStatus.Queue,\n        data: {\n          percentage: 0,\n          speed: 0,\n          speedHuman: `${humanizeBytes(0)}/s`,\n          startTime: null,\n          endTime: null,\n          eta: null,\n          etaHuman: null\n        }\n      },\n      lastModifiedDate: new Date(file.lastModified),\n      sub: undefined,\n      nativeFile: file\n    };\n  }\n  parseResponseHeaders(httpHeaders) {\n    if (!httpHeaders) {\n      return {};\n    }\n    return httpHeaders.split('\\n').map(x => x.split(/: */, 2)).filter(x => x[0]).reduce((acc, x) => {\n      acc[x[0]] = x[1];\n      return acc;\n    }, {});\n  }\n}\nclass NgFileDropDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.stopEvent = e => {\n      e.stopPropagation();\n      e.preventDefault();\n    };\n    this.uploadOutput = new EventEmitter();\n  }\n  ngOnInit() {\n    this._sub = [];\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n    this.el = this.elementRef.nativeElement;\n    this._sub.push(this.upload.serviceEvents.subscribe(event => {\n      this.uploadOutput.emit(event);\n    }));\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n    this.el.addEventListener('drop', this.stopEvent, false);\n    this.el.addEventListener('dragenter', this.stopEvent, false);\n    this.el.addEventListener('dragover', this.stopEvent, false);\n  }\n  ngOnDestroy() {\n    if (this._sub) {\n      this._sub.forEach(sub => sub.unsubscribe());\n    }\n  }\n  onDrop(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    const event = {\n      type: 'drop'\n    };\n    this.uploadOutput.emit(event);\n    this.upload.handleFiles(e.dataTransfer.files);\n  }\n  onDragOver(e) {\n    if (!e) {\n      return;\n    }\n    const event = {\n      type: 'dragOver'\n    };\n    this.uploadOutput.emit(event);\n  }\n  onDragLeave(e) {\n    if (!e) {\n      return;\n    }\n    const event = {\n      type: 'dragOut'\n    };\n    this.uploadOutput.emit(event);\n  }\n  static #_ = this.ɵfac = function NgFileDropDirective_Factory(t) {\n    return new (t || NgFileDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgFileDropDirective,\n    selectors: [[\"\", \"ngFileDrop\", \"\"]],\n    hostBindings: function NgFileDropDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"drop\", function NgFileDropDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        })(\"dragover\", function NgFileDropDirective_dragover_HostBindingHandler($event) {\n          return ctx.onDragOver($event);\n        })(\"dragleave\", function NgFileDropDirective_dragleave_HostBindingHandler($event) {\n          return ctx.onDragLeave($event);\n        });\n      }\n    },\n    inputs: {\n      options: \"options\",\n      uploadInput: \"uploadInput\"\n    },\n    outputs: {\n      uploadOutput: \"uploadOutput\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileDropDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngFileDrop]'\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }], {\n    options: [{\n      type: Input\n    }],\n    uploadInput: [{\n      type: Input\n    }],\n    uploadOutput: [{\n      type: Output\n    }],\n    onDrop: [{\n      type: HostListener,\n      args: ['drop', ['$event']]\n    }],\n    onDragOver: [{\n      type: HostListener,\n      args: ['dragover', ['$event']]\n    }],\n    onDragLeave: [{\n      type: HostListener,\n      args: ['dragleave', ['$event']]\n    }]\n  });\n})();\nclass NgFileSelectDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    this.fileListener = () => {\n      if (this.el.files) {\n        this.upload.handleFiles(this.el.files);\n      }\n    };\n    this.uploadOutput = new EventEmitter();\n  }\n  ngOnInit() {\n    this._sub = [];\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n    this.el = this.elementRef.nativeElement;\n    this.el.addEventListener('change', this.fileListener, false);\n    this._sub.push(this.upload.serviceEvents.subscribe(event => {\n      this.uploadOutput.emit(event);\n    }));\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n  }\n  ngOnDestroy() {\n    if (this.el) {\n      this.el.removeEventListener('change', this.fileListener, false);\n      this._sub.forEach(sub => sub.unsubscribe());\n    }\n  }\n  static #_ = this.ɵfac = function NgFileSelectDirective_Factory(t) {\n    return new (t || NgFileSelectDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgFileSelectDirective,\n    selectors: [[\"\", \"ngFileSelect\", \"\"]],\n    inputs: {\n      options: \"options\",\n      uploadInput: \"uploadInput\"\n    },\n    outputs: {\n      uploadOutput: \"uploadOutput\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileSelectDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngFileSelect]'\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }], {\n    options: [{\n      type: Input\n    }],\n    uploadInput: [{\n      type: Input\n    }],\n    uploadOutput: [{\n      type: Output\n    }]\n  });\n})();\nclass NgxUploaderModule {\n  static #_ = this.ɵfac = function NgxUploaderModule_Factory(t) {\n    return new (t || NgxUploaderModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxUploaderModule,\n    declarations: [NgFileDropDirective, NgFileSelectDirective],\n    exports: [NgFileDropDirective, NgFileSelectDirective]\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxUploaderModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NgFileDropDirective, NgFileSelectDirective],\n      exports: [NgFileDropDirective, NgFileSelectDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-uploader\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgFileDropDirective, NgFileSelectDirective, NgUploaderService, NgxUploaderModule, UploadStatus, humanizeBytes };\n//# sourceMappingURL=ngx-uploader.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}